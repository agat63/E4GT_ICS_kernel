From 94aaae6bee70db6870d8a8b263d2b08058c1f24d Mon Sep 17 00:00:00 2001
From: Gokhan Moral <gm@alumni.bilkent.edu.tr>
Date: Wed, 23 May 2012 08:40:29 +0300
Subject: [PATCH 02/24] cpufreq_hotplug: patch hotplug governor to use
 workqueues when enabling/disabling the second core

---
 drivers/cpufreq/cpufreq_hotplug.c |   30 ++++++++++++++++++++----------
 1 files changed, 20 insertions(+), 10 deletions(-)

diff --git a/drivers/cpufreq/cpufreq_hotplug.c b/drivers/cpufreq/cpufreq_hotplug.c
index 4a1479d..0c609cd 100644
--- a/drivers/cpufreq/cpufreq_hotplug.c
+++ b/drivers/cpufreq/cpufreq_hotplug.c
@@ -67,6 +67,8 @@ struct cpu_dbs_info_s {
 	cputime64_t prev_cpu_nice;
 	struct cpufreq_policy *cur_policy;
 	struct delayed_work work;
+	struct work_struct cpu_up_work;
+	struct work_struct cpu_down_work;
 	struct cpufreq_frequency_table *freq_table;
 	int cpu;
 	/*
@@ -472,6 +474,7 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
 	/* calculate the average load across all related CPUs */
 	avg_load = total_load / num_online_cpus();
 
+	mutex_lock(&dbs_mutex);
 
 	/*
 	 * hotplug load accounting
@@ -515,13 +518,8 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
 		/* should we enable auxillary CPUs? */
 		if (num_online_cpus() < 2 && hotplug_in_avg_load >
 				dbs_tuners_ins.up_threshold) {
-			/* hotplug with cpufreq is nasty
-			 * a call to cpufreq_governor_dbs may cause a lockup.
-			 * wq is not running here so its safe.
-			 */
-			mutex_unlock(&this_dbs_info->timer_mutex);
-			cpu_up(1);
-			mutex_lock(&this_dbs_info->timer_mutex);
+			queue_work_on(this_dbs_info->cpu, khotplug_wq,
+					&this_dbs_info->cpu_up_work);
 			goto out;
 		}
 	}
@@ -543,9 +541,8 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
 			/* should we disable auxillary CPUs? */
 			if (num_online_cpus() > 1 && hotplug_out_avg_load <
 					dbs_tuners_ins.down_threshold) {
-				mutex_unlock(&this_dbs_info->timer_mutex);
-				cpu_down(1);
-				mutex_lock(&this_dbs_info->timer_mutex);
+				queue_work_on(this_dbs_info->cpu, khotplug_wq,
+					&this_dbs_info->cpu_down_work);
 			}
 			goto out;
 		}
@@ -570,9 +567,20 @@ static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
 					 CPUFREQ_RELATION_L);
 	}
 out:
+	mutex_unlock(&dbs_mutex);
 	return;
 }
 
+static void do_cpu_up(struct work_struct *work)
+{
+	cpu_up(1);
+}
+
+static void do_cpu_down(struct work_struct *work)
+{
+	cpu_down(1);
+}
+
 static void do_dbs_timer(struct work_struct *work)
 {
 	struct cpu_dbs_info_s *dbs_info =
@@ -595,6 +603,8 @@ static inline void dbs_timer_init(struct cpu_dbs_info_s *dbs_info)
 	delay -= jiffies % delay;
 
 	INIT_DELAYED_WORK_DEFERRABLE(&dbs_info->work, do_dbs_timer);
+	INIT_WORK(&dbs_info->cpu_up_work, do_cpu_up);
+	INIT_WORK(&dbs_info->cpu_down_work, do_cpu_down);
 	queue_delayed_work_on(dbs_info->cpu, khotplug_wq, &dbs_info->work,
 		delay);
 }
-- 
1.7.5.4

